{% extends "base.html" %}
{% load static %}

{% block content %}
<style>
    .warning-chip {
    display: inline-flex;
    align-items: center;
    gap: .4rem;
    font-size: .8rem;
    padding: .25rem .5rem;
    border-radius: 999px;
    border: 1px solid transparent;
    background: #fff7ed;          
    color: #b45309;               
  }

  .warning-chip.critical {
    background: #fef2f2;          
    color: #b91c1c;               
  }
  .warning-chip .dot {
    width: .5rem; height: .5rem; border-radius: 999px; background:#f59e0b;
  }
  .warning-chip.critical .dot { background:#ef4444; }
  .price-origin-wrapper {
    width: 100%;
  }

  .price-origin-wrapper .price-input {
    width: 100%;
  }

  .price-origin-badge {
    font-size: 0.7rem;
    letter-spacing: 0.02em;
  }

  .price-input-auto {
    background-color: #e7f1ff;
    border-color: rgba(13, 110, 253, 0.35);
  }

  .price-input-manual {
    background-color: #fff5e6;
    border-color: rgba(255, 193, 7, 0.45);
  }

  table th:nth-child(8),
  table td:nth-child(8) {
    width: 100px;          /* adjust to fit your layout */
    max-width: 100px;
    min-width: 100px;
    text-align: justify;     /* keeps prices neatly aligned */
  }
</style>
<div class="section-box position-relative">
  <h5 class="section-title">RAB Preview</h5>

  <div class="row g-3 mb-3">
    <div class="col-lg-6">
      <form id="excelUploadForm" enctype="multipart/form-data" class="h-100 p-3 border rounded bg-light-subtle">
        <label for="excelFileInput" class="form-label fw-semibold">Upload Excel</label>
        <div class="input-group">
          <input type="file" name="file" id="excelFileInput" accept=".xls,.xlsx" class="form-control">
          <button type="submit" class="btn btn-primary" style="background-color:#00365a;">Upload & Preview Excel</button>
        </div>
        <small class="text-muted">Format didukung: .xls, .xlsx</small>
      </form>
    </div>
    <div class="col-lg-6">
      <form id="pdfUploadForm" enctype="multipart/form-data" class="h-100 p-3 border rounded bg-light-subtle">
        <label for="pdfFileInput" class="form-label fw-semibold">Upload PDF</label>
        <div class="input-group">
          <input type="file" name="pdf_file" id="pdfFileInput" accept=".pdf" class="form-control">
          <button type="submit" class="btn btn-primary" style="background-color:#00365a;">Upload & Preview PDF</button>
        </div>
        <small class="text-muted">Format didukung: .pdf</small>
      </form>
    </div>
  </div>

  <div id="errorContainer"></div>
  <div id="loadingSpinner" class="text-center py-4" style="display:none;">
    <div class="spinner-border text-primary" role="status">
      <span class="visually-hidden">Loading...</span>
    </div>
    <p class="mt-2">Memproses file, mohon tunggu...</p>
  </div>

  <div id="rabTables" class="mt-3"></div>

  <div class="grand-total-box card mt-4 p-3 shadow-sm" id="grandTotalBox" style="display:none; max-width:400px;">
    <div class="d-flex justify-content-between"><span class="fw-bold">Total</span> <span id="grandTotal">Rp. 0</span></div>
    <div class="d-flex justify-content-between"><span class="fw-bold">PPN (10%)</span> <span id="ppn">Rp. 0</span></div>
    <div class="d-flex justify-content-between"><span class="fw-bold">Total (Termasuk PPN)</span> <span id="totalWithPpn">Rp. 0</span></div>
    <div class="d-flex justify-content-between"><span class="fw-bold">Terbilang</span> <span id="terbilang">NOL RUPIAH</span></div>
  </div>

  <div class="card mt-4 p-3 shadow-sm" id="targetBidBox" style="display:none;">
    <div class="d-flex justify-content-between align-items-center mb-3">
      <h5 class="mb-0">ðŸŽ¯ Target Bid</h5>
      <span class="badge text-bg-secondary">Beta</span>
    </div>
    <div class="row g-3 align-items-end">
      <div class="col-md-4">
        <label for="targetBudgetMode" class="form-label">Mode</label>
        <select id="targetBudgetMode" class="form-select form-select-sm">
          <option value="percentage" selected>Persentase dari harga saat ini</option>
          <option value="absolute">Nominal (Rp)</option>
        </select>
      </div>
      <div class="col-md-5">
        <label for="targetBudgetInput" class="form-label">Target</label>
        <div class="input-group input-group-sm">
          <span class="input-group-text" id="targetBudgetPrefix">Rp</span>
          <input type="text" id="targetBudgetInput" class="form-control" placeholder="cth: 150000000" inputmode="decimal">
          <span class="input-group-text d-none" id="targetBudgetSuffix">%</span>
        </div>
      </div>
      <div class="col-md-3 d-grid">
        <button type="button" class="btn btn-primary btn-sm" id="applyTargetBidButton">
          <span id="targetBidSpinner" class="spinner-border spinner-border-sm me-2 d-none" role="status" aria-hidden="true"></span>
          Terapkan Target Bid
        </button>
      </div>
    </div>
    <small class="text-muted d-block mt-2" id="targetBidHint">
      Sistem mencoba mengganti material mahal pada setiap AHSP agar total mendekati target.
    </small>
    <div id="targetBidSummary" class="mt-3"></div>
  </div>

  <!-- Cost Weight Analysis Chart -->
  <div class="card mt-4 p-4 shadow-sm" id="costWeightChartBox" style="display:none;">
    <h5 class="mb-3">ðŸ“Š Cost Weight Analysis</h5>
    <div class="row">
      <div class="col-lg-7">
        <canvas id="costWeightPieChart" style="max-height: 400px;"></canvas>
      </div>
      <div class="col-lg-5">
        <div id="costWeightLegend" style="max-height: 400px; overflow-y: auto;"></div>
      </div>
    </div>
  </div>

  {% include "efficiency_recommendations/recommendations_panel.html" %}

  <a href="#" class="btn btn-outline-primary mt-3">+ Tambah Kategori Pekerjaan / Pilih Referensi RAB</a>
</div>
{% endblock %}

{% block extra_js %}
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<script>
  {{ block.super }}

  // Debug: Check if Chart.js is loaded
  console.log("Chart.js loaded:", typeof Chart !== 'undefined');
  console.log("Cost Weight Chart Box element:", document.getElementById("costWeightChartBox"));

  const MATCH_ENDPOINT = "{% url 'match-best' %}";
  const RECOMPUTE_ENDPOINT = "/api/recompute_total_cost/";
  const EXCEL_UPLOAD_ENDPOINT = "{% url 'preview_rows' %}";
  const PDF_UPLOAD_ENDPOINT = "{% url 'pdf_parser:rab_converted_pdf' %}";
  const OPTIMIZE_AHS_ENDPOINT_TEMPLATE = "{% url 'optimize_ahs_materials_view' '__AHS_CODE__' %}";
  const OPTIMIZE_AHS_PLACEHOLDER = "__AHS_CODE__";
  const suggestionCache = new Map();
  const dropdownRequestState = new WeakMap();
  const MANUAL_SUGGESTION_LIMIT = 12;
  const PRICE_OVERRIDE_CONFIRM_MESSAGE = "Harga ini diisi otomatis oleh sistem. Apakah Anda yakin ingin menimpa nilai tersebut secara manual?";
  const SAFE_ROW_KEY_PATTERN = /^[A-Za-z0-9._:-]{1,128}$/;
  const SAFE_NUMERIC_PATTERN = /^-?\d{0,12}(?:[.,]\d{0,4})?$/;
  const UNSAFE_CODE_PATTERN = /[<>]/;

  function escapeHtml(input) {
    if (input === null || input === undefined) {
      return "";
    }
    return String(input)
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#39;");
  }

  function sanitizeRowKey(value, fallback = null) {
    if (typeof value !== "string") {
      return fallback;
    }
    const trimmed = value.trim();
    if (!trimmed) {
      return fallback;
    }
    return SAFE_ROW_KEY_PATTERN.test(trimmed) ? trimmed : fallback;
  }

  function canonicalizeFrontendCode(value) {
    if (typeof value !== "string") {
      return "";
    }
    let text = value.trim().toUpperCase();
    if (!text) {
      return "";
    }
    text = text.replace(/[-_/ ]+/g, ".");
    text = text.replace(/[^A-Z0-9.]/g, "");
    text = text.replace(/\.{2,}/g, ".");
    while (text.includes("..")) {
      text = text.replace("..", ".");
    }
    return text.replace(/^\.+|\.+$/g, "");
  }
  function toDecimalString(value) {
    if (!Number.isFinite(value)) {
      return "";
    }
    const fixed = Number(value).toFixed(6);
    return fixed.replace(/\.0+$/, "").replace(/(\.\d*?[1-9])0+$/, "$1").replace(/\.$/, "");
  }


  function normaliseNumericInput(value, { allowBlank = false } = {}) {
    if (value === undefined || value === null) {
      return allowBlank ? undefined : 0;
    }
    if (typeof value === "string") {
      const trimmed = value.trim();
      if (!trimmed) {
        return allowBlank ? undefined : 0;
      }
      if (!SAFE_NUMERIC_PATTERN.test(trimmed)) {
        return null;
      }
      value = parseFloat(trimmed.replace(",", "."));
    }
    if (!Number.isFinite(value)) {
      return null;
    }
    if (value < 0) {
      return null;
    }
    if (Math.abs(value) > 1_000_000_000_000) {
      return null;
    }
    return Number(value);
  }

  function enforceValidNumericInput(inputEl, fieldLabel, { allowBlank = false } = {}) {
    if (!inputEl) {
      return { value: 0, isValid: true, provided: false };
    }
    const raw = String(inputEl.value ?? "").trim();
    if (!raw) {
      inputEl.classList.remove("is-invalid");
      return { value: 0, isValid: true, provided: false };
    }
    if (!SAFE_NUMERIC_PATTERN.test(raw)) {
      inputEl.classList.add("is-invalid");
      showError(`${fieldLabel} mengandung karakter tidak valid.`);
      return { value: 0, isValid: false, provided: false };
    }
    const numeric = parseFloat(raw.replace(",", "."));
    if (!Number.isFinite(numeric) || numeric < 0 || Math.abs(numeric) > 1_000_000_000_000) {
      inputEl.classList.add("is-invalid");
      showError(`${fieldLabel} harus berupa angka non-negatif yang wajar.`);
      return { value: 0, isValid: false, provided: false };
    }
    inputEl.classList.remove("is-invalid");
    return { value: numeric, isValid: true, provided: true };
  }

  function buildRecomputePayload({ rowKey, code, volume, unitPrice }) {
    const errors = [];
    const payload = {};

    const safeRowKey = sanitizeRowKey(rowKey);
    if (rowKey && !safeRowKey) {
      errors.push("Row key tidak valid.");
    } else if (safeRowKey) {
      payload.row_key = safeRowKey;
    }

    const safeCode = canonicalizeFrontendCode(code || "");
    if (code && !safeCode) {
      errors.push("Kode pekerjaan mengandung karakter tidak sah.");
    } else if (safeCode) {
      payload.code = safeCode;
      payload.analysis_code = safeCode;
    }

    const safeVolume = normaliseNumericInput(volume);
    if (safeVolume === null) {
      errors.push("Volume harus berupa angka non-negatif.");
    } else {
      payload.volume = toDecimalString(safeVolume);
    }

    if (unitPrice !== undefined) {
      const safeUnit = normaliseNumericInput(unitPrice, { allowBlank: true });
      if (safeUnit === null) {
        errors.push("Harga satuan harus berupa angka non-negatif.");
      } else if (safeUnit !== undefined) {
        payload.unit_price = toDecimalString(safeUnit);
      }
    }

    return errors.length ? { errors } : { payload };
  }

  function showError(message) {
    const errorContainer = document.getElementById("errorContainer");
    errorContainer.innerHTML = `<div class="alert alert-danger">${message}</div>`;
    setTimeout(() => (errorContainer.innerHTML = ""), 4000);
  }

  function showLoading() {
    document.getElementById("loadingSpinner").style.display = "block";
  }
  function hideLoading() {
    document.getElementById("loadingSpinner").style.display = "none";
  }

  // ---------- TARGET BID INTEGRATION ----------
  function setTargetBidVisibility(isVisible) {
    const box = document.getElementById("targetBidBox");
    if (!box) {
      return;
    }
    box.style.display = isVisible ? "block" : "none";
    if (isVisible) {
      setTargetBidBusy(false);
      handleTargetBudgetModeChange();
    }
  }

  function setTargetBidBusy(isBusy) {
    const button = document.getElementById("applyTargetBidButton");
    const spinner = document.getElementById("targetBidSpinner");
    const modeSelect = document.getElementById("targetBudgetMode");
    const input = document.getElementById("targetBudgetInput");
    if (button) {
      button.disabled = isBusy;
    }
    if (modeSelect) {
      modeSelect.disabled = isBusy;
    }
    if (input) {
      input.disabled = isBusy;
    }
    if (spinner) {
      spinner.classList.toggle("d-none", !isBusy);
    }
  }

  function resetTargetBidSummary() {
    const summary = document.getElementById("targetBidSummary");
    if (summary) {
      summary.innerHTML = "";
    }
  }

  function handleTargetBudgetModeChange() {
    const modeSelect = document.getElementById("targetBudgetMode");
    const prefix = document.getElementById("targetBudgetPrefix");
    const suffix = document.getElementById("targetBudgetSuffix");
    const input = document.getElementById("targetBudgetInput");
    const hint = document.getElementById("targetBidHint");
    if (!modeSelect || !prefix || !suffix || !input) {
      return;
    }

    const mode = modeSelect.value === "absolute" ? "absolute" : "percentage";
    if (mode === "percentage") {
      prefix.classList.add("d-none");
      suffix.classList.remove("d-none");
      input.placeholder = "cth: 80";
      if (hint) {
        hint.textContent = "Misal 80 berarti target biaya setiap AHSP menjadi 80% dari harga awal.";
      }
    } else {
      prefix.classList.remove("d-none");
      suffix.classList.add("d-none");
      prefix.textContent = "Rp";
      input.placeholder = "cth: 150000000";
      if (hint) {
        hint.textContent = "Masukkan nominal target untuk harga per unit AHSP (rupiah).";
      }
    }
  }

  function readGrandTotalValue() {
    return calculateGrandTotalFromRows();
  }

  function formatCurrencyId(value) {
    const numeric = Number.isFinite(value) ? value : 0;
    return "Rp. " + Number(numeric).toLocaleString("id-ID", {
      minimumFractionDigits: 0,
      maximumFractionDigits: 0,
    });
  }

  function formatCurrencyRp(value, { decimals = 2, fallback = null } = {}) {
    if (value === null || value === undefined || value === "") {
      return fallback;
    }
    const numeric = parseCurrencyNumber(value);
    if (!Number.isFinite(numeric)) {
      return fallback;
    }
    return "Rp. " + numeric.toLocaleString("id-ID", {
      minimumFractionDigits: decimals,
      maximumFractionDigits: decimals,
    });
  }

  function renderTargetBidSummary(details) {
    const summary = document.getElementById("targetBidSummary");
    if (!summary) {
      return;
    }

    const {
      appliedCodes = [],
      failedCodes = [],
      beforeTotal = 0,
      afterTotal = 0,
      targetMode = "percentage",
      targetNumeric = 0,
    } = details || {};

    if (!appliedCodes.length && !failedCodes.length) {
      summary.innerHTML = "<div class=\"alert alert-warning mb-0\">Tidak ada kode AHSP yang dapat disesuaikan untuk target ini.</div>";
      return;
    }

    const targetNominal = targetMode === "percentage"
      ? beforeTotal * (targetNumeric / 100)
      : targetNumeric;
    const gap = Math.abs(afterTotal - targetNominal);
    const direction = afterTotal >= targetNominal ? "lebih tinggi" : "lebih rendah";
    const metCount = appliedCodes.filter(item => item.metTarget).length;

    let failureNote = "";
    if (failedCodes.length) {
      const reported = failedCodes.slice(0, 3).map(entry => entry.code).join(", ");
      const suffix = failedCodes.length > 3 ? ", ..." : "";
      failureNote = `<div class="small text-muted">Gagal memproses: ${reported}${suffix}.</div>`;
    }

    const adjustmentSummaries = appliedCodes
      .map(item => ({
        code: item.code,
        adjustments: Array.isArray(item.adjustedMaterials) ? item.adjustedMaterials : [],
      }))
      .filter(entry => entry.adjustments.length);

    const adjustmentHtml = adjustmentSummaries.length
      ? `
        <div class="mt-3">
          <div class="fw-semibold mb-2">Rincian penyesuaian material:</div>
          ${adjustmentSummaries
            .map(entry => {
              const listItems = entry.adjustments
                .map(material => {
                  const nameText = escapeHtml(material.name || "-");
                  const unitText = material.unit ? ` (${escapeHtml(material.unit)})` : "";
                  const brandLabel = material.brand
                    ? escapeHtml(material.brand)
                    : "Brand tidak tersedia";
                  const newPriceLabel = formatCurrencyRp(material.newUnitPrice, { fallback: null });
                  const originalPriceLabel = formatCurrencyRp(material.originalUnitPrice, { fallback: null });
                  let priceSnippet = "";
                  if (newPriceLabel) {
                    priceSnippet = `${newPriceLabel}`;
                    if (originalPriceLabel && originalPriceLabel !== newPriceLabel) {
                      priceSnippet += ` (dari ${originalPriceLabel})`;
                    }
                  }
                  const extraInfo = priceSnippet ? `, ${priceSnippet}` : "";
                  return `<li class="mb-1">` +
                    `<strong>${nameText}</strong>${unitText} â€” brand <span class="text-primary">${brandLabel}</span>${extraInfo}</li>`;
                })
                .join("");
              return `
                <div class="mb-2">
                  <div class="text-muted small">AHS ${escapeHtml(entry.code || "(tanpa kode)")}</div>
                  <ul class="mb-0 ps-3">${listItems}</ul>
                </div>
              `;
            })
            .join("")
          }
        </div>
      `
      : "";

    summary.innerHTML = `
      <div class="alert alert-info mb-0">
        <div><strong>${appliedCodes.length}</strong> kode AHSP diproses.${failedCodes.length ? ` <span class="text-danger">${failedCodes.length} kode gagal.</span>` : ""}</div>
        <div>Total awal: ${formatCurrencyId(beforeTotal)} â†’ Total sekarang: ${formatCurrencyId(afterTotal)}.</div>
        <div>Target: ${targetMode === "percentage" ? `${targetNumeric}% (${formatCurrencyId(targetNominal)})` : formatCurrencyId(targetNominal)}.</div>
        <div>Selisih terhadap target: ${formatCurrencyId(gap)} (${direction}).</div>
        ${metCount ? `<div>${metCount} kode sudah memenuhi target unitnya.</div>` : ""}
        ${failureNote}
      </div>
      ${adjustmentHtml}
    `;
  }

  function getBaselineAutoPrice(rows) {
    if (!Array.isArray(rows)) {
      return null;
    }
    for (const row of rows) {
      const priceInput = row && row.querySelector ? row.querySelector(".price-input") : null;
      if (!priceInput) {
        continue;
      }
      const baseRaw = priceInput.dataset ? priceInput.dataset.baseAutoPrice : null;
      if (baseRaw !== undefined && baseRaw !== null && baseRaw !== "") {
        const baseNumeric = parseCurrencyNumber(baseRaw);
        if (Number.isFinite(baseNumeric) && baseNumeric > 0) {
          return baseNumeric;
        }
      }
      const refRaw = priceInput.dataset ? priceInput.dataset.referencePrice : null;
      if (refRaw !== undefined && refRaw !== null && refRaw !== "") {
        const refNumeric = parseCurrencyNumber(refRaw);
        if (Number.isFinite(refNumeric) && refNumeric > 0) {
          return refNumeric;
        }
      }
      const inputNumeric = parseCurrencyNumber(priceInput.value);
      if (Number.isFinite(inputNumeric) && inputNumeric > 0) {
        return inputNumeric;
      }
    }
    return null;
  }

  function getRepresentativeVolume(rows) {
    if (!Array.isArray(rows)) {
      return null;
    }
    for (const row of rows) {
      const volumeInput = row && row.querySelector ? row.querySelector(".volume-input") : null;
      if (!volumeInput) {
        continue;
      }
      const numeric = parseCurrencyNumber(volumeInput.value);
      if (Number.isFinite(numeric) && numeric > 0) {
        return numeric;
      }
    }
    return null;
  }

  function deriveOptimizedUnitPrice(rows, optimisationResult) {
    if (!optimisationResult || typeof optimisationResult !== "object") {
      return null;
    }

    const adjustedOverallRaw = optimisationResult.adjusted_totals && optimisationResult.adjusted_totals.overall;
    const originalOverallRaw = optimisationResult.original_totals && optimisationResult.original_totals.overall;
    const adjustedOverall = adjustedOverallRaw !== undefined && adjustedOverallRaw !== null && adjustedOverallRaw !== ""
      ? parseCurrencyNumber(adjustedOverallRaw)
      : null;
    const originalOverall = originalOverallRaw !== undefined && originalOverallRaw !== null && originalOverallRaw !== ""
      ? parseCurrencyNumber(originalOverallRaw)
      : null;

    const baseline = getBaselineAutoPrice(rows);
    if (
      Number.isFinite(baseline) && baseline > 0 &&
      Number.isFinite(adjustedOverall) && adjustedOverall >= 0 &&
      Number.isFinite(originalOverall) && originalOverall > 0
    ) {
      const factor = adjustedOverall / originalOverall;
      if (Number.isFinite(factor) && factor >= 0) {
        return baseline * factor;
      }
    }

    const unitCandidates = optimisationResult.adjusted_totals ? [
      optimisationResult.adjusted_totals.unit_price,
      optimisationResult.adjusted_totals.unitPrice,
      optimisationResult.adjusted_totals.per_unit,
      optimisationResult.adjusted_totals.perUnit,
    ] : [];
    for (const candidate of unitCandidates) {
      if (candidate === undefined || candidate === null || candidate === "") {
        continue;
      }
      const numeric = parseCurrencyNumber(candidate);
      if (Number.isFinite(numeric) && numeric >= 0) {
        return numeric;
      }
    }

    if (Number.isFinite(adjustedOverall)) {
      const volume = getRepresentativeVolume(rows);
      if (Number.isFinite(volume) && volume > 0) {
        return adjustedOverall / volume;
      }
    }

    return null;
  }

  function extractReplacementSummary(response) {
    if (!response || !Array.isArray(response.replacements)) {
      return [];
    }

    const toNumeric = (raw) => {
      if (raw === undefined || raw === null) {
        return null;
      }
      const text = String(raw).trim();
      if (!text) {
        return null;
      }
      const numeric = parseCurrencyNumber(text);
      return Number.isFinite(numeric) ? numeric : null;
    };

    return response.replacements
      .map(entry => {
        if (!entry) {
          return null;
        }
        const alternative = entry.alternative || {};
        const brand = alternative.brand || alternative.brand_name || "";
        const source = alternative.source || "";
        const originalRaw = entry.original_unit_price ?? entry.originalUnitPrice ?? entry.originalUnitPriceRp;
        const newRaw = entry.new_unit_price ?? entry.newUnitPrice ?? entry.adjusted_unit_price ?? entry.adjustedUnitPrice;

        const originalUnitPrice = toNumeric(originalRaw);
        const newUnitPrice = toNumeric(newRaw);

        if (newUnitPrice === null) {
          return null;
        }

        return {
          name: entry.name || entry.material_name || "",
          unit: entry.unit || "",
          brand: brand,
          source,
          originalUnitPrice,
          newUnitPrice,
        };
      })
      .filter(item => item && item.name);
  }

  function applyOptimizedUnitPrice(rows, newUnitPrice) {
    if (!Array.isArray(rows) || !rows.length) {
      return;
    }
    const normalized = Number(newUnitPrice);
    if (!Number.isFinite(normalized) || normalized < 0) {
      return;
    }
    rows.forEach(row => {
      const priceInput = row.querySelector(".price-input");
      const volumeInput = row.querySelector(".volume-input");
      const totalCell = row.querySelector(".total-cell");

      if (priceInput) {
        priceInput.value = normalized;
        priceInput.dataset.referencePrice = String(normalized);
        priceInput.dataset.previousValue = priceInput.value;
        priceInput.dataset.manualConfirmed = "false";
        updatePriceOriginUI(priceInput, "auto");
      }

      if (volumeInput && totalCell) {
        const volume = parseCurrencyNumber(volumeInput.value);
        const newTotal = volume * normalized;
        totalCell.textContent = "Rp. " + newTotal.toLocaleString("id-ID", {
          minimumFractionDigits: 2,
          maximumFractionDigits: 2,
        });
      }

      updatePriceWarningForRow(row);
    });
  }

  async function requestOptimizedAhs(code, payload) {
    const endpoint = OPTIMIZE_AHS_ENDPOINT_TEMPLATE.replace(OPTIMIZE_AHS_PLACEHOLDER, encodeURIComponent(code));
    const response = await fetch(endpoint, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    });

    let data = null;
    try {
      data = await response.json();
    } catch (err) {
      data = null;
    }

    if (!response.ok) {
      const detail = data && (data.detail || data.error);
      throw new Error(detail || "Optimasi target bid gagal diproses.");
    }

    return data;
  }

  function collectRowsByAnalysisCode() {
    const rows = Array.from(document.querySelectorAll("#rabTables tr[data-row-key]"));
    const map = new Map();

    rows.forEach(row => {
      const analysisCell = row.querySelector(".analysis-code-cell");
      if (!analysisCell) {
        return;
      }
      const rawCode = analysisCell.textContent || "";
      const canonical = canonicalizeFrontendCode(rawCode);
      if (!canonical) {
        return;
      }
      if (!map.has(canonical)) {
        map.set(canonical, { rows: [], displayCode: rawCode.trim() || canonical });
      }
      map.get(canonical).rows.push(row);
    });

    return map;
  }

  async function applyTargetBid() {
    const modeSelect = document.getElementById("targetBudgetMode");
    const inputEl = document.getElementById("targetBudgetInput");

    if (!modeSelect || !inputEl) {
      return;
    }

    const mode = modeSelect.value === "absolute" ? "absolute" : "percentage";
    const numericCheck = enforceValidNumericInput(inputEl, "Target budget");
    if (!numericCheck.isValid || !numericCheck.provided) {
      return;
    }

    const numericValue = numericCheck.value;
    if (mode === "percentage" && (numericValue <= 0 || numericValue > 100)) {
      inputEl.classList.add("is-invalid");
      showError("Persentase target harus antara 0 hingga 100.");
      return;
    }
    if (mode === "absolute" && numericValue <= 0) {
      inputEl.classList.add("is-invalid");
      showError("Target nominal harus lebih besar dari nol.");
      return;
    }
    inputEl.classList.remove("is-invalid");

    const groups = collectRowsByAnalysisCode();
    if (!groups.size) {
      showError("Tidak ditemukan kode AHSP yang valid untuk dioptimasi.");
      return;
    }

    const payload = {
      material_limit: 2,
      target_budget: numericValue.toString(),
      mode,
    };

    const beforeTotal = calculateGrandTotalFromRows();
  const targetNominal = mode === "percentage" ? beforeTotal * (numericValue / 100) : numericValue;
  const gapBaseline = Number.isFinite(targetNominal) && targetNominal > 0 ? targetNominal : beforeTotal;
  const TARGET_GAP_RATIO = 0.01;
  const TARGET_GAP_MIN = 10000;
  const targetGapThreshold = Math.max(gapBaseline * TARGET_GAP_RATIO, TARGET_GAP_MIN); // treat â‰¤1% gap (or Rp1.000) as "close enough"
    const appliedCodes = [];
    const failedCodes = [];

    setTargetBidBusy(true);
    resetTargetBidSummary();

    let afterTotal = beforeTotal;
    let stopAdjusting = false;

    try {
      for (const [code, info] of groups.entries()) {
        if (stopAdjusting) {
          break;
        }
        try {
          const data = await requestOptimizedAhs(code, payload);
          const adjustments = extractReplacementSummary(data);
          const derivedUnit = deriveOptimizedUnitPrice(info.rows, data);
          if (derivedUnit !== null && derivedUnit !== undefined && Number.isFinite(derivedUnit)) {
            applyOptimizedUnitPrice(info.rows, derivedUnit);
          } else {
            console.warn("Unable to derive optimized unit price for", code, data);
          }
          updateGrandTotalFromRows(false);
          afterTotal = calculateGrandTotalFromRows();

          const metTarget = data && data.target_budget && data.target_budget.met_after_adjustment === true;
          appliedCodes.push({
            code: info.displayCode || code,
            metTarget,
            remainingGap: parseCurrencyNumber(data && data.target_budget && data.target_budget.remaining_gap),
            adjustedMaterials: adjustments,
          });

          if (Number.isFinite(targetNominal) && targetNominal >= 0) {
            const gapToTarget = Math.abs(afterTotal - targetNominal);
            if (targetNominal > 0) {
              if (gapToTarget <= targetGapThreshold || afterTotal <= targetNominal) {
                stopAdjusting = true;
              }
            } else if (targetNominal === 0 && afterTotal <= targetGapThreshold) {
              stopAdjusting = true;
            }
          }
        } catch (err) {
          console.warn("Target bid optimisation failed for", code, err);
          failedCodes.push({ code: info.displayCode || code, error: err.message || String(err) });
        }
      }

      updateGrandTotalFromRows();
      afterTotal = calculateGrandTotalFromRows();

      if (window.EfficiencyRecommendations && typeof currentTestJobId !== "undefined" && currentTestJobId) {
        try {
          window.EfficiencyRecommendations.refresh();
        } catch (refreshErr) {
          console.warn("Failed to refresh efficiency recommendations after target bid.", refreshErr);
        }
      }

      renderTargetBidSummary({
        appliedCodes,
        failedCodes,
        beforeTotal,
        afterTotal,
        targetMode: mode,
        targetNumeric: numericValue,
      });
    } catch (err) {
      console.error("Target bid application error", err);
      showError("Terjadi kesalahan saat menerapkan target bid: " + (err.message || err));
    } finally {
      setTargetBidBusy(false);
    }
  }

  function setupTargetBidControls() {
    const modeSelect = document.getElementById("targetBudgetMode");
    const button = document.getElementById("applyTargetBidButton");

    if (modeSelect) {
      modeSelect.addEventListener("change", handleTargetBudgetModeChange);
      handleTargetBudgetModeChange();
    }

    if (button) {
      button.addEventListener("click", (event) => {
        event.preventDefault();
        applyTargetBid();
      });
    }
  }

  setupTargetBidControls();

  const excelUploadForm = document.getElementById("excelUploadForm");
  const pdfUploadForm = document.getElementById("pdfUploadForm");

  if (excelUploadForm) {
    excelUploadForm.addEventListener("submit", async (event) => {
      event.preventDefault();
      const fileInput = document.getElementById("excelFileInput");
      if (!fileInput.files.length) {
        showError("Silakan pilih file Excel terlebih dahulu");
        return;
      }

      const formData = new FormData();
      formData.append("file", fileInput.files[0]);

      try {
        showLoading();
        const response = await fetch(EXCEL_UPLOAD_ENDPOINT, { method: "POST", body: formData });
        const data = await response.json();
        hideLoading();

        const rows = data.rows || data.excel_standard || data.excel_apendo;
        if (rows) {
          renderTables(rows, { sourceType: "excel", jobId: data.job_id });
          fileInput.value = "";
        } else {
          showError("Gagal memproses file: " + (data.error || "Terjadi kesalahan yang tidak diketahui"));
        }
      } catch (error) {
        hideLoading();
        showError("Terjadi kesalahan saat mengunggah file: " + error.message);
      }
    });
  }

  if (pdfUploadForm) {
    pdfUploadForm.addEventListener("submit", async (event) => {
      event.preventDefault();
      const fileInput = document.getElementById("pdfFileInput");
      if (!fileInput.files.length) {
        showError("Silakan pilih file PDF terlebih dahulu");
        return;
      }

      const formData = new FormData();
      formData.append("pdf_file", fileInput.files[0]);

      try {
        showLoading();
        const response = await fetch(PDF_UPLOAD_ENDPOINT, { method: "POST", body: formData });
        const data = await response.json();
        hideLoading();

        if (Array.isArray(data.rows) && data.rows.length) {
          renderTables(data.rows, { sourceType: "pdf", jobId: data.job_id });
          fileInput.value = "";
        } else {
          showError("Gagal memproses file: " + (data.error || "Tidak ada baris yang ditemukan"));
        }
      } catch (error) {
        hideLoading();
        showError("Terjadi kesalahan saat mengunggah file: " + error.message);
      }
    });
  }

  // ---------- MAIN TABLE RENDER ----------
  function renderTables(rows, options = {}) {
    const container = document.getElementById("rabTables");
    container.innerHTML = "";

    resetTargetBidSummary();
    setTargetBidVisibility(false);

    if (!Array.isArray(rows) || !rows.length) {
      document.getElementById("grandTotalBox").style.display = "none";
      showError("Tidak ada baris yang dapat ditampilkan");
      return;
    }

    const hasSections = rows.some(row => row && row.is_section);
    if (hasSections) {
      renderSectionedTables(rows, container);
    } else {
      renderFlatTable(rows, container);
    }

    document.getElementById("grandTotalBox").style.display = "block";
    setTargetBidVisibility(true);
    updateGrandTotalFromRows();
  }

  function renderSectionedTables(rows, container) {
    let total = 0;
    let currentTable = null;
    let tbody = null;
    let bujakCounter = 0;

    rows.forEach((row, rowIndex) => {
      const skipKeywords = ["PAJAK", "JUMLAH SETELAH PAJAK", "DIBULATKAN", "TERBILANG"];
      if (row.description && skipKeywords.some(k => row.description.toUpperCase().includes(k))) {
        return;
      }

      if (row.is_section && row.section_type === "CATEGORY" && row.number === "A") {
        bujakCounter++;
        const header = document.createElement("div");
        header.classList.add("alert", "alert-warning", "fw-bold", "mt-3");
        header.innerText = `BUJAK ${bujakCounter}`;
        container.appendChild(header);

        const table = document.createElement("table");
        table.classList.add("table", "table-bordered", "table-sm", "align-middle", "mb-4");
        table.innerHTML = `
          <thead class="table-light">
            <tr>
              <th>No.</th>
              <th>Uraian Pekerjaan</th>
              <th>Kode</th>
              <th>Status Pencocokan</th>
              <th>Hasil AHSP</th>
              <th>Volume</th>
              <th>SAT</th>
              <th>Harga Satuan (Rp.)</th>
              <th>Jumlah</th>
            </tr>
          </thead>
        `;
        const newBody = document.createElement("tbody");
        table.appendChild(newBody);
        container.appendChild(table);

        currentTable = table;
        tbody = newBody;
      }

      if (!currentTable || !tbody) {
        return;
      }

      if (row.is_section && row.section_type === "CATEGORY") {
        const tr = document.createElement("tr");
        const numberCell = document.createElement("td");
        numberCell.textContent = row.number || "";
        tr.appendChild(numberCell);

        const titleCell = document.createElement("td");
        titleCell.colSpan = 8;
        const strong = document.createElement("strong");
        strong.textContent = row.description || "";
        titleCell.appendChild(strong);
        tr.appendChild(titleCell);

        tbody.appendChild(tr);
        return;
      }

      if (row.is_section && row.section_type === "SECTION") {
        const tr = document.createElement("tr");
        const numberCell = document.createElement("td");
        numberCell.textContent = row.number || "";
        tr.appendChild(numberCell);

        const titleCell = document.createElement("td");
        titleCell.colSpan = 8;
        const emphasis = document.createElement("em");
        emphasis.textContent = row.description || "";
        titleCell.appendChild(emphasis);
        tr.appendChild(titleCell);

        tbody.appendChild(tr);
        return;
      }

      if (row.is_section) {
        return;
      }

      const tr = buildDataRow(row, rowIndex);
      tbody.appendChild(tr);
      total += parseCurrencyNumber(row.total_price);

      const matchCell = tr.querySelector("td:nth-child(5)");
      const analysisCell = tr.querySelector(".analysis-code-cell");
      const statusCell = tr.querySelector("td:nth-child(4)");
      populateMatchCell(matchCell, row, analysisCell, statusCell);

    });

    updateGrandTotal(total);
  }
  
  function renderFlatTable(rows, container) {
    let total = 0;

    const table = document.createElement("table");
    table.classList.add("table", "table-bordered", "table-sm", "align-middle", "mb-4");
    table.innerHTML = `
      <thead class="table-light">
        <tr>
          <th>No.</th>
          <th>Uraian Pekerjaan</th>
          <th>Kode</th>
          <th>Status Pencocokan</th>
          <th>Hasil AHSP</th>
          <th>Volume</th>
          <th>SAT</th>
          <th>Harga Sat (Rp.)</th>
          <th>Jumlah </th>
        </tr>
      </thead>
    `;

    const tbody = document.createElement("tbody");
    table.appendChild(tbody);
    container.appendChild(table);

    rows.forEach((row, rowIndex) => {
      if (row.job_match_status === "skipped" && (!row.is_section || row.is_section === undefined)) {
        const tr = document.createElement("tr");

        const numberCell = document.createElement("td");
        numberCell.textContent = row.number || "";
        tr.appendChild(numberCell);

        const titleCell = document.createElement("td");
        titleCell.colSpan = 8;
        const strong = document.createElement("strong");
        strong.textContent = row.description || "";
        titleCell.appendChild(strong);
        tr.appendChild(titleCell);

        tr.classList.add("table-secondary", "fw-semibold");
        tbody.appendChild(tr);
        return;
      }

      const tr = buildDataRow(row, rowIndex, { flatNumbering: true });
      tbody.appendChild(tr);
      total += parseCurrencyNumber(row.total_price);
    });

    // âœ… Just populate matches from backend - no async fetching
    rows.forEach((row, rowIndex) => {
      const tr = tbody.rows[rowIndex];
      const matchCell = tr.querySelector("td:nth-child(5)");
      const analysisCell = tr.querySelector(".analysis-code-cell");
      const statusCell = tr.querySelector("td:nth-child(4)");
      populateMatchCell(matchCell, row, analysisCell, statusCell);
    });


    updateGrandTotal(total);
  }

  function buildDataRow(row, rowIndex, options = {}) {
    const tr = document.createElement("tr");
    const sanitizedRowKey = sanitizeRowKey(row.row_key || row.rowKey, `row-${rowIndex}`);
    tr.dataset.rowKey = sanitizedRowKey || `row-${rowIndex}`;
    const rowKey = tr.dataset.rowKey;

    const numberCell = document.createElement("td");
    numberCell.textContent = options.flatNumbering ? (row.number || rowIndex + 1) : (row.number || "");
    tr.appendChild(numberCell);

    const descriptionCell = document.createElement("td");
    descriptionCell.textContent = row.description || "";
    const descInner = document.createElement("div");
    descInner.className = "d-flex flex-column";
    const title = document.createElement("div");
    title.textContent = row.description || "";
    const warnHost = document.createElement("div");
    warnHost.className = "price-warning-host mt-1"; 
    descInner.appendChild(title);
    descInner.appendChild(warnHost);
    descriptionCell.textContent = "";
    descriptionCell.appendChild(descInner);
    tr.appendChild(descriptionCell);

    const analysisCell = document.createElement("td");
    analysisCell.classList.add("analysis-code-cell");
    analysisCell.textContent = row.analysis_code || row.analysisCode || row.code || "";
    analysisCell.dataset.rowKey = rowKey;
    tr.appendChild(analysisCell);

    const statusCell = document.createElement("td");
    statusCell.textContent = formatMatchStatusText(row);
    tr.appendChild(statusCell);

    const matchCell = document.createElement("td");
    populateMatchCell(matchCell, row, analysisCell, statusCell);
    tr.appendChild(matchCell);

    const volumeCell = document.createElement("td");
    const volumeInput = document.createElement("input");
    volumeInput.type = "number";
    volumeInput.className = "form-control form-control-sm volume-input";
    volumeInput.value = parseCurrencyNumber(row.volume);
    volumeInput.min = "0";
    volumeInput.step = "0.01";
    volumeInput.dataset.rowIndex = rowIndex;
    volumeInput.dataset.rowKey = rowKey;
    volumeCell.appendChild(volumeInput);
    tr.appendChild(volumeCell);

    const unitCell = document.createElement("td");
    unitCell.textContent = row.unit || row.sat || "";
    tr.appendChild(unitCell);

    const priceCell = document.createElement("td");
    const priceWrapper = document.createElement("div");
    priceWrapper.className = "price-origin-wrapper d-flex flex-column align-items-start gap-1";

    const priceInput = document.createElement("input");
    priceInput.type = "number";
    priceInput.className = "form-control form-control-sm price-input";
    const initialUnitPrice = parseCurrencyNumber(row.price);
    priceInput.value = initialUnitPrice;
    priceInput.min = "0";
    priceInput.step = "0.01";
    priceInput.dataset.rowIndex = rowIndex;
    priceInput.dataset.rowKey = rowKey;
    if (Number.isFinite(initialUnitPrice)) {
      priceInput.dataset.referencePrice = String(initialUnitPrice);
      priceInput.dataset.baseAutoPrice = String(initialUnitPrice);
    }
    priceWrapper.appendChild(priceInput);

    const badge = document.createElement("span");
    badge.className = "price-origin-badge badge rounded-pill";
    badge.textContent = "Manual";
    priceWrapper.appendChild(badge);

    priceCell.appendChild(priceWrapper);
    tr.appendChild(priceCell);

    const initialOrigin = ((row.price_origin || row.priceOrigin || "").toLowerCase() === "auto") ? "auto" : "manual";
    decoratePriceInput(priceInput, { initialOrigin });

    const totalCell = document.createElement("td");
    totalCell.classList.add("total-cell");
    totalCell.textContent = "Rp. " + formatCurrencyValue(row.total_price);
    tr.appendChild(totalCell);

    return tr;
  }

  function refreshTooltip(element) {
    if (!element || typeof window === "undefined" || !window.bootstrap || !bootstrap.Tooltip) {
      return;
    }
    const existing = bootstrap.Tooltip.getInstance(element);
    if (existing) {
      existing.dispose();
    }
    if (element.getAttribute("title")) {
      new bootstrap.Tooltip(element);
    }
  }

  function updatePriceOriginUI(priceInput, origin, options = {}) {
    if (!priceInput) {
      return;
    }

    const normalizedOrigin = origin === "auto" ? "auto" : "manual";
    priceInput.dataset.origin = normalizedOrigin;
    priceInput.classList.remove("price-input-auto", "price-input-manual");
    priceInput.classList.add(normalizedOrigin === "auto" ? "price-input-auto" : "price-input-manual");

    const wrapper = priceInput.closest(".price-origin-wrapper");
    if (wrapper) {
      let badge = wrapper.querySelector(".price-origin-badge");
      if (!badge) {
        badge = document.createElement("span");
        badge.className = "price-origin-badge badge rounded-pill";
        badge.textContent = "";
        wrapper.appendChild(badge);
      }
      const baseClass = "price-origin-badge badge rounded-pill";
      if (normalizedOrigin === "auto") {
        badge.className = `${baseClass} bg-info-subtle text-info-emphasis`;
        badge.textContent = "Auto";
      } else {
        badge.className = `${baseClass} bg-warning-subtle text-warning-emphasis`;
        badge.textContent = "Manual";
      }
    }

    const tooltipText = normalizedOrigin === "auto"
      ? "Harga ini berasal dari referensi otomatis sistem."
      : "Harga ini saat ini merupakan nilai manual.";
    priceInput.setAttribute("data-bs-toggle", "tooltip");
    priceInput.setAttribute("data-bs-placement", "top");
    priceInput.setAttribute("title", tooltipText);

    if (!options.skipTooltipRefresh) {
      refreshTooltip(priceInput);
    }
  }

  function decoratePriceInput(priceInput, { initialOrigin = "manual" } = {}) {
    if (!priceInput) {
      return;
    }

    const wrapper = priceInput.closest(".price-origin-wrapper");
    if (wrapper && !wrapper.querySelector(".price-origin-badge")) {
      const badge = document.createElement("span");
      badge.className = "price-origin-badge badge rounded-pill";
      badge.textContent = "Manual";
      wrapper.appendChild(badge);
    }

    const normalizedOrigin = initialOrigin === "auto" ? "auto" : "manual";
    priceInput.dataset.overrideMessage = PRICE_OVERRIDE_CONFIRM_MESSAGE;
    priceInput.dataset.origin = normalizedOrigin;
    priceInput.dataset.manualConfirmed = normalizedOrigin === "auto" ? "false" : "true";
    priceInput.dataset.previousValue = priceInput.value;

    updatePriceOriginUI(priceInput, normalizedOrigin);
  }

  function shouldProceedWithPriceChange(priceInput, event) {
    if (!priceInput) {
      return true;
    }

    if (!event.isTrusted) {
      priceInput.dataset.previousValue = priceInput.value;
      return true;
    }

    const origin = priceInput.dataset.origin || "manual";
    const isConfirmedManual = priceInput.dataset.manualConfirmed === "true";

    if (origin === "auto" && !isConfirmedManual) {
      const message = priceInput.dataset.overrideMessage || PRICE_OVERRIDE_CONFIRM_MESSAGE;
      const confirmed = window.confirm(message);
      if (!confirmed) {
        const revertValue = priceInput.dataset.previousValue !== undefined ? priceInput.dataset.previousValue : "";
        priceInput.value = revertValue;
        updatePriceOriginUI(priceInput, "auto");
        priceInput.dataset.manualConfirmed = "false";
        refreshTooltip(priceInput);
        return false;
      }
    }

    updatePriceOriginUI(priceInput, "manual");
    priceInput.dataset.manualConfirmed = "true";
    priceInput.dataset.previousValue = priceInput.value;
    return true;
  }

  document.addEventListener("focusin", (event) => {
    if (event.target && event.target.classList && event.target.classList.contains("price-input")) {
      event.target.dataset.previousValue = event.target.value;
    }
  });

  // ---------- AUTO PRICE MATCHING LOGIC ----------
  let backendRecomputeTimeout = null;
  
  document.addEventListener("input", async (event) => {
    if (!event.target.classList.contains("volume-input") && !event.target.classList.contains("price-input")) return;

    if (event.target.classList.contains("price-input")) {
      const proceed = shouldProceedWithPriceChange(event.target, event);
      if (!proceed) {
        return;
      }
    }

    const row = event.target.closest("tr");
    if (!row) {
      return;
    }
    const volumeInput = row.querySelector(".volume-input");
    const priceInput = row.querySelector(".price-input");
    const totalCell = row.querySelector(".total-cell");

    const volumeCheck = enforceValidNumericInput(volumeInput, "Volume");
    const priceCheck = enforceValidNumericInput(priceInput, "Harga satuan", { allowBlank: true });
    if (!volumeCheck.isValid || !priceCheck.isValid) {
      return;
    }

    const volume = volumeCheck.value;
    const price = priceCheck.provided ? priceCheck.value : 0;

    // Instant UI update (no delay)
    const total = volume * price;
    totalCell.textContent = "Rp. " + total.toLocaleString("id-ID", { minimumFractionDigits: 2, maximumFractionDigits: 2 });

    // Update grand total immediately
    updateGrandTotalFromRows();

    // Debounce backend recomputation: wait 800ms after last keystroke
    if (backendRecomputeTimeout) {
      clearTimeout(backendRecomputeTimeout);
    }
    
    backendRecomputeTimeout = setTimeout(async () => {
      // Backend recomputation (precise rounding & persistence)
      try {
        const analysisCell = row.querySelector(".analysis-code-cell");
        const rawCode = analysisCell ? analysisCell.textContent.trim() : "";
        const rowKey = row.dataset.rowKey || null;
        const payloadResult = buildRecomputePayload({
          rowKey,
          code: rawCode,
          volume,
          unitPrice: priceCheck.provided ? price : undefined,
        });

        if (payloadResult.errors) {
          showError(payloadResult.errors.join(" "));
          return;
        }

        const payload = payloadResult.payload;

        const response = await fetch(RECOMPUTE_ENDPOINT, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });
        const data = await response.json();
        if (response.ok && data.total_cost !== undefined && data.total_cost !== null) {
          const precise = parseFloat(data.total_cost);
          if (!Number.isNaN(precise)) {
            totalCell.textContent = "Rp. " + precise.toLocaleString("id-ID", { minimumFractionDigits: 2, maximumFractionDigits: 2 });
          }
          if (data.unit_price !== undefined && data.unit_price !== null) {
            const resolvedUnit = parseFloat(data.unit_price);
            if (!Number.isNaN(resolvedUnit)) {
              priceInput.value = resolvedUnit;
              priceInput.dataset.previousValue = priceInput.value;
            }
          }
          // Update grand total but don't reset pie chart timer
          updateGrandTotalFromRows(false);
        }
      } catch (err) {
        console.warn("Fetch error:", err);
      }
    }, 800); // Wait 800ms before backend call
  });

  // ---------- Grand Total Update ----------
  let costWeightChart = null;
  let chartUpdateTimeout = null;

  function calculateGrandTotalFromRows() {
    let total = 0;
    document.querySelectorAll(".total-cell").forEach(cell => {
      const numeric = parseCurrencyNumber(cell.textContent);
      if (Number.isFinite(numeric)) {
        total += numeric;
      }
    });
    return total;
  }

  function updateGrandTotalFromRows(shouldUpdateChart = true) {
    const grand = calculateGrandTotalFromRows();

    // Update Grand Total immediately (no delay)
    updateGrandTotal(grand);

    // Only reset pie chart timer if triggered by user input (not backend callback)
    if (shouldUpdateChart) {
      if (chartUpdateTimeout) {
        clearTimeout(chartUpdateTimeout);
      }
      chartUpdateTimeout = setTimeout(() => {
        updateCostWeightChart();
      }, 2000); // Wait 2 seconds before updating chart
    }
  }

  function updateGrandTotal(total) {
    document.getElementById("grandTotal").innerText = "Rp. " + total.toLocaleString();
    const ppn = total * 0.1;
    document.getElementById("ppn").innerText = "Rp. " + ppn.toLocaleString();
    document.getElementById("totalWithPpn").innerText = "Rp. " + (total + ppn).toLocaleString();
    document.getElementById("terbilang").innerText =
      total === 0 ? "NOL RUPIAH" : numberToWords(total + ppn).toUpperCase();
  }

  function updateCostWeightChart() {
    // Collect all items with their costs
    const items = [];
    const tables = document.querySelectorAll("#rabTables table");
    
    tables.forEach(table => {
      const rows = table.querySelectorAll("tbody tr");
      rows.forEach(row => {
        // Get description from second td (index 1)
        const cells = row.querySelectorAll("td");
        if (cells.length < 9) return; // Skip if not enough cells
        
        const descCell = cells[1]; // Uraian Pekerjaan
        const totalCell = row.querySelector(".total-cell");
        
        if (descCell && totalCell) {
          const description = descCell.textContent.trim();
          const totalText = totalCell.textContent.replace(/[^\d,.-]/g, "").replace(/\./g, "").replace(",", ".");
          const cost = parseFloat(totalText) || 0;
          
          if (cost > 0 && description && description !== "") {
            items.push({ name: description, cost: cost });
          }
        }
      });
    });

    console.log("Cost Weight Chart - Items found:", items.length, items);

    if (items.length === 0) {
      document.getElementById("costWeightChartBox").style.display = "none";
      return;
    }

    // Calculate total and weights
    const totalCost = items.reduce((sum, item) => sum + item.cost, 0);
    items.forEach(item => {
      item.weight = (item.cost / totalCost) * 100;
    });

    // Sort by cost descending
    items.sort((a, b) => b.cost - a.cost);

    // Take top 10 items for clarity
    const topItems = items.slice(0, 10);
    if (items.length > 10) {
      const othersTotal = items.slice(10).reduce((sum, item) => sum + item.cost, 0);
      topItems.push({ 
        name: `Others (${items.length - 10} items)`, 
        cost: othersTotal,
        weight: (othersTotal / totalCost) * 100
      });
    }

    // Prepare chart data
    const labels = topItems.map(item => item.name);
    const costs = topItems.map(item => item.cost);
    const weights = topItems.map(item => item.weight);
    const colors = [
      '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', 
      '#9966FF', '#FF9F40', '#FF6384', '#C9CBCF',
      '#E7E9ED', '#FFA1B5', '#8DD3C7'
    ];

    // Show chart box
    document.getElementById("costWeightChartBox").style.display = "block";

    // Render chart
    const ctx = document.getElementById("costWeightPieChart");
    
    if (costWeightChart) {
      costWeightChart.destroy();
    }

    costWeightChart = new Chart(ctx, {
      type: 'pie',
      data: {
        labels: labels,
        datasets: [{
          data: costs,
          backgroundColor: colors,
          borderWidth: 2,
          borderColor: '#fff'
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            display: false
          },
          title: {
            display: true,
            text: 'Cost Distribution by Item',
            font: {
              size: 16,
              weight: 'bold'
            }
          },
          tooltip: {
            callbacks: {
              label: function(context) {
                const label = context.label || '';
                const value = context.parsed;
                const weight = weights[context.dataIndex];
                return `${label}: Rp ${value.toLocaleString('id-ID')} (${weight.toFixed(2)}%)`;
              }
            }
          }
        }
      }
    });

    // Render custom legend
    const legendContainer = document.getElementById("costWeightLegend");
    legendContainer.innerHTML = '<h6 class="mb-3">Items Breakdown</h6>';
    
    topItems.forEach((item, index) => {
      const legendItem = document.createElement('div');
      legendItem.className = 'd-flex align-items-center mb-2 p-2 rounded';
      legendItem.style.cursor = 'pointer';
      legendItem.innerHTML = `
        <div style="width: 20px; height: 20px; background: ${colors[index]}; border-radius: 4px; margin-right: 10px; flex-shrink: 0;"></div>
        <div style="flex-grow: 1; font-size: 0.85rem;">
          <div style="font-weight: 600; color: #333;">${item.name}</div>
          <div style="font-size: 0.75rem; color: #666;">Rp ${item.cost.toLocaleString('id-ID')} (${item.weight.toFixed(2)}%)</div>
        </div>
      `;
      legendItem.addEventListener('mouseenter', () => {
        legendItem.style.background = '#f8f9fa';
      });
      legendItem.addEventListener('mouseleave', () => {
        legendItem.style.background = 'transparent';
      });
      legendContainer.appendChild(legendItem);
    });
  }

  function numberToWords(number) {
    return number.toLocaleString("id-ID") + " rupiah";
  }

  function formatMatchStatusText(row) {
    if (row.job_match_selected) {
      if (row.job_match_selected.match_status === "Manual" || row.job_match_status === "manual") {
        return "Manual";
      }
      return "Dipilih";
    }

    const status = row.job_match_status;
    if (!status || status === "skipped") {
      return "Skipped";
    }
    if (status === "error") {
      return "Error";
    }

    const matches = normalizeMatches(row.job_match);
    const fallback = matches.find(entry => entry && entry.match_status && !entry.code);
    if (fallback) {
      return fallback.match_status;
    }

    return status.replace(/(^|\s)\w/g, letter => letter.toUpperCase());
  }

  function getBestConfidenceMatch(matches) {
    if (!Array.isArray(matches) || !matches.length) return null;
    return matches.reduce((best, m) => {
      if (!m || typeof m.confidence !== "number") return best;
      return !best || m.confidence > best.confidence ? m : best;
    }, null);
  }

  function populateMatchCell(cell, row, analysisCell, statusCell) {
    cell.innerHTML = "";

    if (row.job_match_status === "error") {
      const errorNotice = document.createElement("div");
      errorNotice.className = "text-danger small mb-2";
      errorNotice.textContent = row.job_match_error ? `Error: ${row.job_match_error}` : "Error";
      cell.appendChild(errorNotice);
      renderManualInput(cell, row, analysisCell, statusCell, "", {
        noticeClass: selectableMatches.length ? "text-muted small mb-2" : "text-warning small mb-2"
      });
      return;
    }

    const matches = normalizeMatches(row.job_match);
    const lookup = updateRowLookup(row, matches);
    const selectableMatches = matches.filter(m => m && m.code);
    const fallbackMessages = matches.filter(m => !m || !m.code);

    // === FOUND CASES ===
    if (selectableMatches.length === 1) {
      // âœ… Automatically match the single result
      const match = selectableMatches[0];
      row.job_match_selected = match;
      row.analysis_code = match.code;
      analysisCell.textContent = match.code;
      statusCell.textContent = "Dipilih (Auto)";
      statusCell.classList.remove("text-danger");
      statusCell.classList.add("text-success");

      const span = document.createElement("span");
      span.className = "text-success fw-semibold";
      span.textContent = buildMatchLabel(match);
      cell.appendChild(span);

      const tr = analysisCell.closest("tr");
      if (tr) setTimeout(() => setPriceForRow(match, tr), 0);
    }

    else if (selectableMatches.length > 1) {
      const bestMatch = getBestConfidenceMatch(selectableMatches);

      // Auto-select best match
      if (bestMatch) {
        row.job_match_selected = bestMatch;
        row.analysis_code = bestMatch.code || "";
        updateRowLookup(row, [bestMatch]);

        analysisCell.textContent = row.analysis_code;
        statusCell.textContent = "Dipilih (Auto)";
        statusCell.classList.add("text-success");

        const matchLabel = document.createElement("span");
        matchLabel.className = "text-success fw-bold";
        matchLabel.textContent = buildMatchLabel(bestMatch);
        cell.appendChild(matchLabel);

        // Fetch price for best match
        const tr = analysisCell.closest("tr");
        if (tr) {
          setPriceForRow(bestMatch, tr);
        }
      }
    }

    else {
      // No matches, fallback to manual
      statusCell.textContent = "Not found";
      statusCell.classList.add("text-danger");
    }

    // Always show manual input for all cases
    renderManualInput(cell, row, analysisCell, statusCell, "", {
      noticeClass: selectableMatches.length ? "text-muted small mb-2" : "text-warning small mb-2"
    });

  }


  function normalizeMatches(matchData) {
    if (!matchData) {
      return [];
    }
    return Array.isArray(matchData) ? matchData : [matchData];
  }

  function buildMatchLabel(match) {
    const pieces = [];
    if (match.code) {
      pieces.push(match.code);
    }
    if (match.name) {
      pieces.push(match.name);
    }
    if (typeof match.confidence === "number") {
      const pct = Math.round(match.confidence * 100);
      pieces.push(`${pct}%`);
    }
    return pieces.length ? pieces.join(" â€“ ") : "Pilih";
  }

  async function handleMatchSelection(match, row, analysisCell, statusCell, matchCell, button) {
    row.job_match_selected = match;
    row.analysis_code = match.code || "";
    updateRowLookup(row, [match]);

    analysisCell.textContent = row.analysis_code;
    statusCell.textContent = "Dipilih";
    statusCell.classList.add("text-success");

    matchCell.querySelectorAll("button.match-option").forEach(btn => {
      btn.classList.remove("btn-success");
      btn.classList.add("btn-outline-primary");
      if (btn.dataset.label) {
        btn.textContent = btn.dataset.label;
      }
    });

    button.classList.remove("btn-outline-primary");
    button.classList.add("btn-success");
    button.textContent = `Dipilih: ${button.dataset.label}`;

    // AFTER selection: try to fetch unit price and set Harga Sat for this row
    const tr = analysisCell.closest("tr");
    if (tr) {
      await setPriceForRow(match, tr);
    }
  }

  function renderManualInput(cell, row, analysisCell, statusCell, label, options = {}) {
    cell.style.position = "relative";

    const group = document.createElement("div");
    group.className = options.groupClass || "input-group input-group-sm manual-match-group";

    const input = document.createElement("input");
    input.type = "text";
    input.className = "form-control";
    input.placeholder = "Masukkan kode atau pilih sugesti";
    input.value = "";
    input.autocomplete = "off";

    const dropdown = document.createElement("div");
    dropdown.className = "dropdown-menu w-100";
    dropdown.style.maxHeight = "200px";
    dropdown.style.overflowY = "auto";
    dropdown.style.display = "none";
    dropdown.style.left = "0";
    dropdown.style.top = "100%";
    dropdown.style.zIndex = "1000";

    const button = document.createElement("button");
    button.type = "button";
    button.className = "btn btn-primary";
    button.textContent = "Gunakan";

    const warnIfUnsafeCode = (value) => {
      if (!value || !UNSAFE_CODE_PATTERN.test(value)) {
        input.classList.remove("is-invalid");
        delete input.dataset.warnedUnsafeCode;
        return false;
      }
      input.classList.add("is-invalid");
      if (input.dataset.warnedUnsafeCode !== "true") {
        showError("Kode AHSP tidak boleh mengandung karakter < atau >.");
        input.dataset.warnedUnsafeCode = "true";
      }
      return true;
    };

    const applyManual = async () => {
  const value = input.value.trim();
  if (!value) {
    input.focus();
    return;
  }

  if (warnIfUnsafeCode(value)) {
    input.focus();
    return;
  }

  const matched = findMatchByCode(row, value);
  row.analysis_code = value;
  row.job_match_selected = matched ? { ...matched, match_status: "Manual" } : {
    code: value,
    match_status: "Manual",
  };
  row.job_match_status = "manual";
  updateRowLookup(row, matched ? [matched] : []);

  analysisCell.textContent = value;
  statusCell.textContent = "Manual";
  statusCell.classList.add("text-success");

  // Update all match option buttons
  cell.querySelectorAll("button.match-option").forEach(btn => {
    btn.classList.remove("btn-success");
    btn.classList.add("btn-outline-primary");
    if (btn.dataset.label) {
      btn.textContent = btn.dataset.label;
    }
  });

  // âœ… UPDATE: Also update the green match label if it exists
  const existingMatchLabel = cell.querySelector(".text-success.fw-semibold, .text-success.fw-bold");
  if (existingMatchLabel) {
    if (matched) {
      existingMatchLabel.textContent = buildMatchLabel(matched);
    } else {
      existingMatchLabel.textContent = `${value} â€“ Manual`;
    }
  }

  button.classList.remove("btn-primary");
  button.classList.add("btn-success");
  button.textContent = "Dipakai";
  dropdown.style.display = "none";

  // AFTER manual apply: try to fetch unit price and set Harga Sat for this row
  const tr = analysisCell.closest("tr");
  if (tr) {
    await setPriceForRow(row.job_match_selected || { code: value }, tr);
  }
};


    button.addEventListener("click", applyManual);
    input.addEventListener("keydown", event => {
      if (event.key === "Enter") {
        event.preventDefault();
        applyManual();
      }
    });

    let dropdownDebounce;
    const triggerDropdown = () => showDropdown(input, dropdown, row, label);
    input.addEventListener("focus", triggerDropdown);
    input.addEventListener("input", () => {
      warnIfUnsafeCode(input.value);
      clearTimeout(dropdownDebounce);
      dropdownDebounce = setTimeout(triggerDropdown, 200);
    });
    input.addEventListener("blur", () => {
      setTimeout(() => {
        dropdown.style.display = "none";
      }, 150);
    });

    dropdown.addEventListener("mousedown", event => {
      event.preventDefault();
    });

  warnIfUnsafeCode(input.value);

  group.appendChild(input);
    group.appendChild(button);
    cell.appendChild(group);
    cell.appendChild(dropdown);
  }

  function showDropdown(input, dropdown, row, label) {
    const query = input.value.trim();
    const lookupMatches = filterMatches(Array.from(getMatchLookup(row).values()), query);

    if (lookupMatches.length) {
      renderDropdownOptions(dropdown, lookupMatches, input);
    } else {
      renderDropdownOptions(dropdown, [], input, { placeholderText: label || "Mencari saran..." });
    }

    const requestToken = Symbol("suggestion-request");
    dropdownRequestState.set(dropdown, requestToken);

    fetchAndStoreSuggestions(row, query).then(allMatches => {
      if (dropdownRequestState.get(dropdown) !== requestToken) {
        return;
      }

      const combined = filterMatches(dedupeMatches(allMatches), query);
      if (combined.length) {
        renderDropdownOptions(dropdown, combined, input);
      } else {
        renderDropdownOptions(dropdown, [], input, { placeholderText: "Tidak ada saran" });
      }
    });
  }

  function getMatchLookup(row) {
    if (!row._matchLookup || !(row._matchLookup instanceof Map)) {
      row._matchLookup = new Map();
    }
    return row._matchLookup;
  }

  function updateRowLookup(row, matches) {
    const lookup = getMatchLookup(row);
    const list = Array.isArray(matches) ? matches : [matches];
    list.forEach(match => {
      if (match && match.code) {
        lookup.set(match.code.toLowerCase(), match);
      }
    });
    return lookup;
  }

  function filterMatches(matches, query) {
    const lowered = (query || "").trim().toLowerCase();
    if (!lowered) {
      return matches;
    }
    return matches.filter(match => {
      if (!match || !match.code) {
        return false;
      }
      const code = match.code.toLowerCase();
      const name = (match.name || "").toLowerCase();
      return code.includes(lowered) || name.includes(lowered);
    });
  }

  function renderDropdownOptions(dropdown, matches, input, options = {}) {
    const { placeholderText } = options;
    dropdown.innerHTML = "";

    if (!matches.length) {
      if (placeholderText) {
        const info = document.createElement("div");
        info.className = "dropdown-item-text text-muted";
        info.textContent = placeholderText;
        dropdown.appendChild(info);
        const width = input.getBoundingClientRect().width;
        dropdown.style.minWidth = `${width}px`;
        dropdown.style.display = "block";
        dropdown.classList.add("show");
      } else {
        dropdown.style.display = "none";
        dropdown.classList.remove("show");
      }
      return;
    }

    const width = input.getBoundingClientRect().width;
    dropdown.style.minWidth = `${width}px`;

    matches.slice(0, MANUAL_SUGGESTION_LIMIT).forEach(match => {
      if (!match || !match.code) {
        return;
      }
      const item = document.createElement("button");
      item.type = "button";
      item.className = "dropdown-item text-wrap";
      let label = `${match.code} â€“ ${match.name || ""}`;
      if (typeof match.confidence === "number") {
          const pct = Math.round(match.confidence * 100);
          label += ` â€“ ${pct}%`;
      }
      item.textContent = label;
      item.addEventListener("click", () => {
        input.value = match.code;
        dropdown.style.display = "none";
        input.focus();
      });
      dropdown.appendChild(item);
    });

    const shouldShow = dropdown.childElementCount > 0;
    dropdown.style.display = shouldShow ? "block" : "none";
    dropdown.classList.toggle("show", shouldShow);
  }

  function dedupeMatches(matches) {
    const map = new Map();
    matches.forEach(match => {
      if (!match || !match.code) {
        return;
      }
      const key = match.code.toLowerCase();
      if (!map.has(key)) {
        map.set(key, match);
      }
    });
    return Array.from(map.values());
  }

  function fetchRemoteSuggestions(row, query, limit = MANUAL_SUGGESTION_LIMIT) {
    const trimmedQuery = (query || "").trim();
    const description = trimmedQuery || (row.description || "").trim();
    if (!description) {
      return Promise.resolve([]);
    }

    const unit = (row.unit || row.sat || "").trim();

    // === Prevent outdated async responses ===
    const requestToken = Symbol("match-request");
    row._lastRequestToken = requestToken;

    // === Build cache key (include unit) ===
    const cacheKey = unit ? `${description}|${unit}|${limit}` : `${description}|${limit}`;
    if (suggestionCache.has(cacheKey)) {
      return suggestionCache.get(cacheKey);
    }

    // === Build payload ===
    const payload = { description };
    if (unit) payload.unit = unit;

    const request = fetch(MATCH_ENDPOINT, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      body: JSON.stringify(payload),
    })
      .then(res => (res.ok ? res.json() : { match: [] }))
      .then(data => {
        // ðŸ§  Ignore stale responses
        if (row._lastRequestToken !== requestToken) {
          console.debug("âš ï¸ Ignored stale match response for:", description);
          return [];
        }

        // === Normal matches (same-unit) ===
        if (data.match) {
            const matchList = Array.isArray(data.match) ? data.match : [data.match];
            return matchList.filter(m => m && m.code);
        }

        // === No results ===
        return [];
      })
      .catch(err => {
        console.warn("Fetch error in fetchRemoteSuggestions:", err);
        return [];
      });

    suggestionCache.set(cacheKey, request);
    return request;
  }



  function fetchAndStoreSuggestions(row, query) {
    return fetchRemoteSuggestions(row, query).then(results => {
      updateRowLookup(row, results);

      if (!results || !results.length) {
        row.job_match = [];
      } else {
        row.job_match = results;
      }

      return Array.from(getMatchLookup(row).values());
    });
  }


  function findMatchByCode(row, code) {
    const lookup = getMatchLookup(row);
    if (!code) {
      return null;
    }
    return lookup.get(code.toLowerCase()) || null;
  }

  // Helper: parse numeric-ish strings into numbers
  function parseCurrencyNumber(value) {
    if (typeof value === "number") {
      return Number.isFinite(value) ? value : 0;
    }
    if (value === null || value === undefined) {
      return 0;
    }
    let text = String(value).trim();
    if (!text) {
      return 0;
    }

    text = text.replace(/\s+/g, "");
    text = text.replace(/[A-Za-z]/g, "");

    let cleaned = text.replace(/[^0-9,.-]/g, "");
    if (!cleaned || cleaned === "-" || cleaned === "." || cleaned === ",") {
      return 0;
    }

    const lastComma = cleaned.lastIndexOf(",");
    const lastDot = cleaned.lastIndexOf(".");

    if (lastComma > -1 && lastDot > -1) {
      if (lastComma > lastDot) {
        cleaned = cleaned.replace(/\./g, "").replace(/,/g, ".");
      } else {
        cleaned = cleaned.replace(/,/g, "");
      }
    } else if (lastComma > -1) {
      cleaned = cleaned.replace(/,/g, ".");
    } else if (lastDot > -1) {
      cleaned = cleaned.replace(/\.(?=.*\.)/g, "");
    }

    const numeric = Number.parseFloat(cleaned);
    return Number.isFinite(numeric) ? numeric : 0;
  }

  function formatCurrencyValue(value) {
    return parseCurrencyNumber(value).toLocaleString("id-ID", {
      minimumFractionDigits: 2,
      maximumFractionDigits: 2,
    });
  }

  function showMatchingSpinner(priceCell) {
    priceCell.innerHTML = `
      <div class="d-flex align-items-center justify-content-center text-secondary" style="gap:6px; font-size: 0.85rem;">
        <div class="spinner-border spinner-border-sm text-secondary" role="status" style="width: 0.9rem; height: 0.9rem;"></div>
        <span>Matching...</span>
      </div>
    `;
  }

  // ---------------- NEW: setPriceForRow helper ----------------
  async function setPriceForRow(match, tr) {
    const volumeInput = tr.querySelector(".volume-input");
    const priceInput = tr.querySelector(".price-input");
    const totalCell = tr.querySelector(".total-cell");
    if (!priceInput) return;



    // prefer any price present on match object (various keys)
    const possiblePrice = match && (match.unit_price ?? match.price ?? match.unitPrice ?? match.unitPriceRp ?? null);
    if (possiblePrice !== null && possiblePrice !== undefined && String(possiblePrice).trim() !== "") {
      const num = parseFloat(String(possiblePrice).replace(/[^0-9.-]/g, ""));
      if (!Number.isNaN(num)) {
        priceInput.value = num;
  priceInput.dataset.baseAutoPrice = String(num);
  priceInput.dataset.referencePrice = String(num);
  updatePriceWarningForRow(tr);
        priceInput.dataset.previousValue = priceInput.value;
        priceInput.dataset.manualConfirmed = "false";
        updatePriceOriginUI(priceInput, "auto");
        priceInput.dispatchEvent(new Event("input", { bubbles: true }));
        return;
      }
    }

    // else, call backend recompute endpoint to resolve price by code + current volume
    const code = match && match.code ? match.code : "";
    if (!code) return;

    const priceCell = priceInput.closest("td");
    const priceWrapper = priceInput.closest(".price-origin-wrapper");
    if (priceCell) {
      if (priceWrapper && priceWrapper.parentElement === priceCell) {
        priceCell.removeChild(priceWrapper);
      }
      showMatchingSpinner(priceCell);
    }

    const rawVolumeValue = volumeInput ? volumeInput.value : 0;
    const safeVolume = normaliseNumericInput(rawVolumeValue);
    if (safeVolume === null) {
      showError("Volume harus berupa angka non-negatif.");
      if (priceCell) {
        priceCell.innerHTML = "";
        if (priceWrapper) {
          priceCell.appendChild(priceWrapper);
        }
      }
      return;
    }
    const volume = safeVolume === undefined ? 0 : safeVolume;
    const rowKey = tr.dataset.rowKey || null;
    const payloadResult = buildRecomputePayload({ rowKey, code, volume });
    if (payloadResult.errors) {
      showError(payloadResult.errors.join(" "));
      if (priceCell) {
        priceCell.innerHTML = "";
        if (priceWrapper) {
          priceCell.appendChild(priceWrapper);
        }
      }
      return;
    }
    const payload = payloadResult.payload;

    try {
      const resp = await fetch(RECOMPUTE_ENDPOINT, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
      });

      if (priceCell) {
        priceCell.innerHTML = "";
        if (priceWrapper) {
          priceCell.appendChild(priceWrapper);
        }
      }

      if (!resp.ok) {
        return;
      }
      const data = await resp.json();
      const serverUnit = data && (data.unit_price ?? data.unitPrice ?? null);
      if (serverUnit !== null && serverUnit !== undefined && String(serverUnit).trim() !== "") {
        const num = parseFloat(String(serverUnit).replace(/[^0-9.-]/g, ""));
        if (!Number.isNaN(num)) {
          priceInput.value = num;
          priceInput.dataset.baseAutoPrice = String(num);
          priceInput.dataset.referencePrice = String(num);
          priceInput.dataset.previousValue = priceInput.value;
          priceInput.dataset.manualConfirmed = "false";
          updatePriceOriginUI(priceInput, "auto");
          // trigger existing input handler to recalc totals & backend rounding
          priceInput.dispatchEvent(new Event("input", { bubbles: true }));

          // if backend returned precise total, update total cell
          if (data.total_cost !== undefined && totalCell) {
            const precise = parseFloat(data.total_cost) || 0;
            totalCell.textContent = "Rp. " + precise.toLocaleString("id-ID", { minimumFractionDigits: 2, maximumFractionDigits: 2 });
            updateGrandTotalFromRows(false); // Don't reset chart timer from backend callback
            updatePriceWarningForRow(row);
          }
        }
      }
    } catch (err) {
      console.warn("Failed to fetch unit price for code:", code, err);
      if (priceCell) {
        priceCell.innerHTML = "";
        if (priceWrapper) {
          priceCell.appendChild(priceWrapper);
        }
      }
    }
  }
  function computeDeviationInfo(actual, reference) {
  const ref = parseFloat(reference);
  const act = parseFloat(actual);
  if (!isFinite(ref) || ref <= 0 || !isFinite(act)) return null;

  const pct = ((act - ref) / ref) * 100;
  const absPct = Math.abs(pct);

  let level = null;
  if (absPct > 50) level = "CRITICAL";
  else if (absPct > 20) level = "WARN";
  else if (absPct > 10) level = "MODERATE";
  else level = "NONE";

  return { pct, absPct, level, direction: pct >= 0 ? "higher" : "lower" };
}

function renderWarningChip(host, info) {
  host.innerHTML = "";
  if (!info || info.level === "NONE") return;

  const chip = document.createElement("span");
  chip.className = "warning-chip" + (info.level === "CRITICAL" ? " critical" : "");
  const dot = document.createElement("span");
  dot.className = "dot";
  const text = document.createElement("span");

  const dirText = info.pct >= 0 ? "lebih tinggi" : "lebih rendah";
  text.textContent = `Harga ${info.absPct.toFixed(1)}% ${dirText} dari database`;

  chip.appendChild(dot);
  chip.appendChild(text);
  host.appendChild(chip);
}

function updatePriceWarningForRow(tr) {
    if (!tr) return;
    const priceInput = tr.querySelector(".price-input");
    const host = tr.querySelector(".price-warning-host");
    if (!priceInput || !host) return;

    const reference = priceInput.dataset.referencePrice;
    if (!reference) {
        host.innerHTML = "";
        return;
    }

    const info = computeDeviationInfo(priceInput.value, reference);
    renderWarningChip(host, info);

}
</script>

<!-- Include Efficiency Recommendations JavaScript -->
<script src="{% static 'efficiency_recommendations/recommendations.js' %}"></script>
<script>
  // Initialize efficiency recommendations after table is rendered
  // This will be called when data is loaded
  let currentTestJobId = null;

  // Hook into the existing renderTables function to trigger recommendations
  const originalRenderTables = renderTables;
  renderTables = function(rows, options = {}) {
    // Call original function
    originalRenderTables(rows, options);
    
    // Extract job_id from response if available
    if (options.jobId) {
      currentTestJobId = options.jobId;
      // Initialize recommendations panel
      if (window.EfficiencyRecommendations) {
        window.EfficiencyRecommendations.init(currentTestJobId);
      }
    }
  };

  // Also trigger refresh when price inputs change
  document.addEventListener('input', function(event) {
    if (event.target.classList.contains('price-input')) {
      // Debounce the refresh to avoid too many API calls
      if (window.EfficiencyRecommendations && currentTestJobId) {
        clearTimeout(window.refreshRecommendationsTimeout);
        window.refreshRecommendationsTimeout = setTimeout(() => {
          window.EfficiencyRecommendations.refresh();
        }, 2000); // Wait 2 seconds after last price change
      }
    }
  });
</script>
{% endblock %}